!(function(e, t) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = t(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], t)
: (e.THREESSAAUnbiasedPass = t(e.THREE));
})(this, function(e) {
"use strict";
e = e && e.hasOwnProperty("default") ? e.default : e;
var t = {
defines: {NUMBER_TEXTURE: 0},
uniforms: {texture: {value: null}},
vertexShader: [
"varying vec2 vUv;",
"void main() {",
"vUv = uv;",
"gl_Position = vec4( position, 1.0 );",
"}"
].join("\n"),
fragmentShader: [
"uniform sampler2D texture[ NUMBER_TEXTURE ];",
"varying vec2 vUv;",
"void main() {",
"vec4 color = vec4(0,0,0,0);",
"for (int i = 0; i < NUMBER_TEXTURE; i++)",
"{",
"color += texture2D( texture[i], vUv);",
"}",
"float nbrTex = float(NUMBER_TEXTURE);",
"gl_FragColor = color/nbrTex;",
"}"
].join("\n")
},
r = function(r, n, i, a) {
e.Pass.call(this),
(this.scene = r),
(this.camera = n),
(this.autoCheckChange = !1),
(this.newBuffer = null),
(this.oldBuffer = null),
(this.changed = !1),
(this.finalRenderDone = !1),
(this.sampleLevelMin = void 0 !== i ? i : 2),
(this.sampleLevelMax = void 0 !== a ? a : 5),
void 0 === t &&
console.error("THREE.SSAAUnbiasedPass relies on UnbiasedShader");
var s = t;
(this.uniforms = e.UniformsUtils.clone(s.uniforms)),
(this.texture = []),
(this.material = []);
for (var d = 0; d < 4; d++)
(this.material[d] = new e.ShaderMaterial({
uniforms: this.uniforms,
vertexShader: s.vertexShader,
fragmentShader: s.fragmentShader
})),
(this.material[d].defines.NUMBER_TEXTURE = Math.pow(2, d));
"101" !== e.REVISION &&
console.error(
"In next versions of threejs line 41 to 47:\n this.quad = new THREE.Pass.FullScreenQuad( this.material );"
),
(this.cameraQuad = new e.OrthographicCamera(-1, 1, 1, -1, 0, 1)),
(this.sceneQuad = new e.Scene()),
(this.quad = new e.Mesh(new e.PlaneBufferGeometry(2, 2), this.material)),
(this.quad.frustumCulled = !1),
this.sceneQuad.add(this.quad),
(this.renderTarget = []),
(this.nextRenderIndex = 0),
(this.uniformsMean = e.UniformsUtils.clone(s.uniforms)),
(this.textureMean = []),
(this.materialMean = new e.ShaderMaterial({
uniforms: this.uniformsMean,
vertexShader: s.vertexShader,
fragmentShader: s.fragmentShader
})),
(this.materialMean.defines.NUMBER_TEXTURE = 8),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs line 67 to 73:\n this.quadMean = new THREE.Pass.FullScreenQuad( this.materialMean );"
),
(this.sceneQuadMean = new e.Scene()),
(this.quadMean = new e.Mesh(
new e.PlaneBufferGeometry(2, 2),
this.materialMean
)),
(this.quadMean.frustumCulled = !1),
this.sceneQuadMean.add(this.quadMean),
(this.renderTargetMean = []),
(this.nextRenderMeanIndex = 0),
(this.materialCompare = new e.ShaderMaterial({
uniforms: {oldRender: {value: null}, newRender: {value: null}},
vertexShader: [
"varying vec2 vUv;",
"void main() {",
"   vUv = uv;",
"   gl_Position = vec4( position, 1.0 );",
"}"
].join("\n"),
fragmentShader: [
"uniform sampler2D oldRender;",
"uniform sampler2D newRender;",
"varying vec2 vUv;",
"void main() {",
"\tvec4 oldRender = texture2D( oldRender, vUv );",
"\tvec4 newRender = texture2D( newRender, vUv );",
"   float diff = clamp(abs(oldRender[0]-newRender[0]) + abs(oldRender[1]-newRender[1]) + abs(oldRender[2]-newRender[2]) + abs(oldRender[3]-newRender[3]),0.0,1.0);",
"   gl_FragColor = vec4(diff,0.0,0.0,0.0);",
"}"
].join("\n")
})),
(this.quadCompare = new e.Mesh(
new e.PlaneBufferGeometry(2, 2),
this.materialCompare
)),
(this.quadCompare.frustumCulled = !1),
(this.sceneQuadCompare = new e.Scene()),
this.sceneQuadCompare.add(this.quadCompare),
(this.materialSubdivide = new e.ShaderMaterial({
uniforms: {render: {value: null}},
vertexShader: [
"varying vec2 vUv;",
"void main() {",
"   vUv = uv;",
"   gl_Position = vec4( position, 1.0 );",
"}"
].join("\n"),
fragmentShader: [
"uniform sampler2D render;",
"varying vec2 vUv;",
"void main() {",
"\tvec4 lowerLeft = texture2D( render, vUv );",
"\tvec4 upperLeft = texture2D( render, vec2(vUv[0],vUv[1]+0.5) );",
"\tvec4 lowerRight = texture2D( render, vec2(vUv[0]+0.5,vUv[1]) );",
"\tvec4 upperRight = texture2D( render, vec2(vUv[0]+0.5,vUv[1]+0.5) );",
"   float diff = lowerLeft[0]  + upperLeft[0] + lowerRight[0] + upperRight[0];",
"   gl_FragColor = vec4(diff,0.,0.,0.);",
"}"
].join("\n")
})),
(this.quadSubdivide = new e.Mesh(
new e.PlaneBufferGeometry(2, 2),
this.materialSubdivide
)),
(this.quadSubdivide.frustumCulled = !1),
(this.quadSubdivide.geometry.attributes.uv.array[1] /= 2),
(this.quadSubdivide.geometry.attributes.uv.array[2] /= 2),
(this.quadSubdivide.geometry.attributes.uv.array[3] /= 2),
(this.quadSubdivide.geometry.attributes.uv.array[6] /= 2),
(this.sceneQuadSubdivide = new e.Scene()),
this.sceneQuadSubdivide.add(this.quadSubdivide);
};
(r.prototype = Object.assign(Object.create(e.Pass.prototype), {
constructor: r,
dispose: function() {
for (var e = 0; e < 4; e++) this.material[e].dispose();
for (e = 0; e < this.renderTarget.length; e++)
this.renderTarget[e] && this.renderTarget[e].dispose();
for (e = 0; e < this.renderTargetMean.length; e++)
this.renderTargetMean[e] && this.renderTargetMean[e].dispose();
this.sceneQuad.dispose();
for (e = 0; e < 4; e++) this.sceneQuadMean[e].dispose();
this.materialMean.dispose(),
this.materialCompare.dispose(),
this.newRender &&
(this.newRender.dispose(),
this.oldRender && this.oldRender.dispose(),
this.renderTargetCompare && this.renderTargetCompare.dispose(),
this.sceneQuadCompare && this.sceneQuadCompare.dispose());
},
setCamera: function(e) {
this.camera != e &&
((this.camera = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setScene: function(e) {
this.scene != e &&
((this.scene = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setSampleLevelMax: function(e) {
this.sampleLevelMax != e &&
((this.sampleLevelMax = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0)),
this.sampleLevelMax < this.sampleLevelMin &&
console.error("SampleLevelMax must be higher than sampleLevelMin");
},
setSampleLevelMin: function(e) {
(this.sampleLevelMin = e),
this.sampleLevelMax < this.sampleLevelMin &&
console.error("SampleLevelMax must be higher than sampleLevelMin");
},
hasChanged: function() {
this.changed ||
((this.changed = !0),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setAutoCheckChange: function(e) {
this.autoCheckChange = e;
},
setSize: function(e, t) {
for (var r = 0; r < this.renderTarget.length; r++)
this.renderTarget[r] && this.renderTarget[r].setSize(e, t),
this.renderTargetMean[r] && this.renderTargetMean[r].setSize(e, t);
if (this.newRender) {
var n = Math.pow(2, Math.ceil(Math.log2(e))),
i = Math.pow(2, Math.ceil(Math.log2(t)));
(this.newRender.width === n && this.newRender.height === i) ||
(this.newRender.setSize(n, i),
this.renderTargetCompare && this.renderTargetCompare.setSize(n, i),
this.renderTargetSubdivide && this.renderTargetSubdivide.setSize(n / 2, i / 2),
this.oldRender && this.oldRender.setSize(n, i),
this.buffer && (this.buffer = new Uint8Array(n * i)));
}
this.hasChanged();
},
createRenderTarget: function(t, r, n, i) {
for (
var a = Math.min(i, 8), s = this.nextRenderIndex % 8, d = 0;
d < Math.min(a, Math.pow(2, this.sampleLevelMax) - this.nextRenderIndex);
d++
) {
var h = n.width,
o = n.height;
this.renderTarget[d + s] ||
(this.renderTarget[d + s] = new e.WebGLRenderTarget(h, o, {
minFilter: e.LinearFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat
}));
var l = this.changed ? 8 * this.nextRenderMeanIndex : this.nextRenderIndex,
u = this.jitterOffsets[l + d];
this.camera.setViewOffset &&
this.camera.setViewOffset(h, o, 0.0625 * u[0], 0.0625 * u[1], h, o),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs :\n render.setRenderTarget(this.renderTarget[ i + beginning ]); \n renderer.clear(); \n this.renderer( this.scene, this.camera);"
),
t.render(this.scene, this.camera, this.renderTarget[d + s]);
}
return (
this.changed ||
(this.nextRenderIndex = Math.min(
this.nextRenderIndex + a,
Math.pow(2, this.sampleLevelMax)
)),
i - a
);
},
meanCalculation: function(t, r, n, i) {
this.jitterOffsets =
e.SSAAUnbiasedPass.JitterVectors[Math.max(0, Math.min(i, 5))];
for (
var a = this.changed
? this.jitterOffsets.length
: Math.pow(2, this.sampleLevelMin);
0 != a;

) {
a = this.createRenderTarget(t, r, n, a);
var s = this.changed ? this.jitterOffsets.length : this.nextRenderIndex;
if (s >= 8 && this.jitterOffsets.length > 8) {
if (s % 8 == 0) {
this.renderTargetMean[this.nextRenderMeanIndex] ||
(this.renderTargetMean[this.nextRenderMeanIndex] = new e.WebGLRenderTarget(
n.width,
n.height,
{
minFilter: e.LinearFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat,
depthBuffer: !1,
stencilBuffer: !1
}
));
for (var d = 0; d < 8; d++) this.textureMean[d] = this.renderTarget[d].texture;
(this.uniformsMean.texture.value = this.textureMean),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs :\n render.setRenderTarget( [this.nextRenderMeanIndex] ); \n this.quadMean( renderer );"
),
t.render(
this.sceneQuadMean,
this.cameraQuad,
this.renderTargetMean[this.nextRenderMeanIndex]
),
(this.texture[this.nextRenderMeanIndex] = this.renderTargetMean[
this.nextRenderMeanIndex
].texture),
(this.uniforms.texture.value = this.texture),
this.nextRenderMeanIndex++;
}
this.quad.material = this.material[Math.trunc(s / 16)];
} else {
this.quad.material = this.material[this.changed ? i : Math.trunc(Math.log2(s))];
for (d = 0; d < Math.min(s, 8); d++)
this.texture[d] = this.renderTarget[d].texture;
this.uniforms.texture.value = this.texture;
}
}
},
render: function(t, r, n) {
var i = -1,
a = t.autoClear;
t.autoClear = !0;
var s = t.getClearColor().getHex(),
d = t.getClearAlpha();
if (!this.changed && this.autoCheckChange) {
var h = Math.pow(2, Math.ceil(Math.log2(n.width))),
o = Math.pow(2, Math.ceil(Math.log2(n.height)));
if (
((this.newRender =
this.newRender ||
new e.WebGLRenderTarget(h, o, {
minFilter: e.LinearFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat
})),
t.render(this.scene, this.camera, this.newRender),
this.oldRender)
) {
(this.materialCompare.uniforms.newRender.value = this.newRender.texture),
(this.materialCompare.uniforms.oldRender.value = this.oldRender.texture),
t.render(this.sceneQuadCompare, this.camera, this.renderTargetCompare),
(this.materialSubdivide.uniforms.render.value = this.renderTargetCompare.texture),
t.render(this.sceneQuadSubdivide, this.camera, this.renderTargetSubdivide),
(this.buffer = this.buffer || new Uint8Array(h * o)),
t.readRenderTargetPixels(
this.renderTargetSubdivide,
0,
0,
h / 2,
o / 2,
this.buffer
),
console.log(this.buffer.length);
for (var l = 0; l < this.buffer.length; l += 4)
if (0 !== this.buffer[l]) {
this.hasChanged();
break;
}
var u = this.oldRender;
(this.oldRender = this.newRender), (this.newRender = u);
} else
(this.renderTargetCompare = new e.WebGLRenderTarget(h, o, {
minFilter: e.LinearFilter,
magFilter: e.NearestFilter,
format: e.RGBFormat,
depthBuffer: !1,
stencilBuffer: !1
})),
(this.renderTargetSubdivide = new e.WebGLRenderTarget(h / 2, o / 2, {
minFilter: e.LinearFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat,
depthBuffer: !1,
stencilBuffer: !1
})),
this.hasChanged(),
(this.oldRender = this.newRender),
(this.newRender = null);
}
this.changed
? ((i = this.sampleLevelMin),
  (this.finalRenderDone = !1),
  (this.nextRenderMeanIndex = 0))
: (i = this.sampleLevelMax),
this.finalRenderDone ||
(this.meanCalculation(t, r, n, i),
this.nextRenderIndex === Math.pow(2, this.sampleLevelMax) &&
(this.finalRenderDone = !0)),
this.renderToScreen
? ("101" !== e.REVISION &&
  console.error(
  "In next versions of threejs :\n renderer.setRenderTarget( null ); \n this.quad.render( renderer );"
  ),
  t.render(this.sceneQuad, this.cameraQuad))
: ("101" !== e.REVISION &&
  console.error(
  "In next versions of threejs :\n renderer.setRenderTarget( writeBuffer ); \n if ( this.clear ) renderer.clear();\n this.quad.render( renderer );"
  ),
  t.render(this.sceneQuad, this.cameraQuad, r)),
this.camera.clearViewOffset && this.camera.clearViewOffset(),
(t.autoClear = a),
t.setClearColor(s, d),
(this.changed = !1);
}
})),
(r.JitterVectors = [
[[0, 0]],
[[4, 4], [-4, -4]],
[[-2, -6], [6, -2], [-6, 2], [2, 6]],
[[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]],
[
[1, 1],
[-1, -3],
[-3, 2],
[4, -1],
[-5, -2],
[2, 5],
[5, 3],
[3, -5],
[-2, 6],
[0, -7],
[-4, -6],
[-6, 4],
[-8, 0],
[7, -4],
[6, 7],
[-7, -8]
],
[
[-4, -7],
[-7, -5],
[-3, -5],
[-5, -4],
[-1, -4],
[-2, -2],
[-6, -1],
[-4, 0],
[-7, 1],
[-1, 2],
[-6, 3],
[-3, 3],
[-7, 6],
[-3, 6],
[-5, 7],
[-1, 7],
[5, -7],
[1, -6],
[6, -5],
[4, -4],
[2, -3],
[7, -2],
[1, -1],
[4, -1],
[2, 1],
[6, 2],
[0, 4],
[4, 4],
[2, 5],
[7, 5],
[5, 6],
[3, 7]
]
]);
var n = r;
return (
(e.SSAAUnbiasedPass = n),
(e.SSAAUnbiasedShader = t),
{SSAAUnbiasedPass: n, SSAAUnbiasedShader: t}
);
});
