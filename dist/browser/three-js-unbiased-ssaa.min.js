!(function(e, t) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = t(require("three-full")))
: "function" == typeof define && define.amd
? define(["three-full"], t)
: (e.THREESSAAUnbiasedPass = t(e.THREE));
})(this, function(e) {
"use strict";
e = e && e.hasOwnProperty("default") ? e.default : e;
var t = {
defines: {NUMBER_TEXTURE: 0},
uniforms: {texture: {value: null}},
vertexShader: [
"varying vec2 vUv;",
"void main() {",
"vUv = uv;",
"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
"}"
].join("\n"),
fragmentShader: [
"uniform sampler2D texture[ NUMBER_TEXTURE ];",
"varying vec2 vUv;",
"void main() {",
"vec4 color = vec4(0,0,0,0);",
"for (int i = 0; i < NUMBER_TEXTURE; i++)",
"{",
"color += texture2D( texture[i], vUv);",
"}",
"float nbrTex = float(NUMBER_TEXTURE);",
"gl_FragColor = color/nbrTex;",
"}"
].join("\n")
},
r = function(r, n, a, i) {
e.Pass.call(this),
(this.scene = r),
(this.camera = n),
(this.autoCheckChange = !1),
(this.newBuffer = null),
(this.oldBuffer = null),
(this.changed = !1),
(this.finalRenderDone = !1),
(this.sampleLevelMin = void 0 !== a ? a : 2),
(this.sampleLevelMax = void 0 !== i ? i : 5),
void 0 === t &&
console.error("THREE.SSAAUnbiasedPass relies on UnbiasedShader");
var s = t;
(this.uniforms = e.UniformsUtils.clone(s.uniforms)),
(this.texture = []),
(this.material = []);
for (var h = 0; h < 4; h++)
(this.material[h] = new e.ShaderMaterial({
uniforms: this.uniforms,
vertexShader: s.vertexShader,
fragmentShader: s.fragmentShader
})),
(this.material[h].defines.NUMBER_TEXTURE = Math.pow(2, h));
"101" !== e.REVISION &&
console.error(
"In next versions of threejs line 41 to 47:\n this.quad = new THREE.Pass.FullScreenQuad( this.material );"
),
(this.cameraQuad = new e.OrthographicCamera(-1, 1, 1, -1, 0, 1)),
(this.sceneQuad = new e.Scene()),
(this.quad = new e.Mesh(new e.PlaneBufferGeometry(2, 2), this.material)),
(this.quad.frustumCulled = !1),
this.sceneQuad.add(this.quad),
(this.renderTarget = []),
(this.nextRenderIndex = 0),
(this.uniformsMean = e.UniformsUtils.clone(s.uniforms)),
(this.textureMean = []),
(this.materialMean = new e.ShaderMaterial({
uniforms: this.uniformsMean,
vertexShader: s.vertexShader,
fragmentShader: s.fragmentShader
})),
(this.materialMean.defines.NUMBER_TEXTURE = 8),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs line 67 to 73:\n this.quadMean = new THREE.Pass.FullScreenQuad( this.materialMean );"
),
(this.sceneQuadMean = new e.Scene()),
(this.quadMean = new e.Mesh(
new e.PlaneBufferGeometry(2, 2),
this.materialMean
)),
(this.quadMean.frustumCulled = !1),
this.sceneQuadMean.add(this.quadMean),
(this.renderTargetMean = []),
(this.nextRenderMeanIndex = 0),
(this.materialCompare = new e.ShaderMaterial({
uniforms: {oldRender: {value: null}, newRender: {value: null}},
vertexShader: [
"varying vec2 vUv;",
"void main() {",
"   vUv = uv;",
"   gl_Position = vec4(position,1);",
"}"
].join("\n"),
fragmentShader: [
"uniform sampler2D oldRender;",
"uniform sampler2D newRender;",
"varying vec2 vUv;",
"void main() {",
"\tvec4 oldRender = texture2D( oldRender, vUv );",
"\tvec4 newRender = texture2D( newRender, vUv );",
"   gl_FragColor = vec4(abs(oldRender[0]-newRender[0]) + abs(oldRender[1]-newRender[1]) + abs(oldRender[2]-newRender[2]) + abs(oldRender[3]-newRender[3]),0,0,0);",
"}"
].join("\n")
}));
};
(r.prototype = Object.assign(Object.create(e.Pass.prototype), {
constructor: r,
dispose: function() {
for (var e = 0; e < 4; e++) this.material[e].dispose();
for (e = 0; e < this.renderTarget.length; e++)
this.renderTarget[e] &&
(this.renderTarget[e].dispose(), (this.renderTarget[e] = null));
for (e = 0; e < this.renderTargetMean.length; e++)
this.renderTargetMean[e] &&
(this.renderTargetMean[e].dispose(), (this.renderTargetMean[e] = null));
this.sceneQuad.dispose();
for (e = 0; e < 4; e++) this.sceneQuadMean[e].dispose();
this.materialMean.dispose(),
this.materialCompare.dispose(),
this.newRender && this.newRender.dispose(),
this.oldRender && this.oldRender.dispose();
},
setCamera: function(e) {
this.camera != e &&
((this.camera = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setScene: function(e) {
this.scene != e &&
((this.scene = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setSampleLevelMax: function(e) {
this.sampleLevelMax != e &&
((this.sampleLevelMax = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0)),
this.sampleLevelMax < this.sampleLevelMin &&
console.error("SampleLevelMax must be higher than sampleLevelMin");
},
setSampleLevelMin: function(e) {
(this.sampleLevelMin = e),
this.sampleLevelMax < this.sampleLevelMin &&
console.error("SampleLevelMax must be higher than sampleLevelMin");
},
hasChanged: function() {
this.changed ||
((this.changed = !0),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setAutoCheckChange: function(e) {
this.autoCheckChange = e;
},
setSize: function(e, t) {
for (var r = 0; r < this.renderTarget.length; r++)
this.renderTarget[r] && this.renderTarget[r].setSize(e, t),
this.renderTargetMean[r] && this.renderTargetMean[r].setSize(e, t);
this.hasChanged();
},
createRenderTarget: function(t, r, n, a) {
for (
var i = Math.min(a, 8), s = this.nextRenderIndex % 8, h = 0;
h < Math.min(i, Math.pow(2, this.sampleLevelMax) - this.nextRenderIndex);
h++
) {
var d = n.width,
o = n.height;
this.renderTarget[h + s] ||
(this.renderTarget[h + s] = new e.WebGLRenderTarget(d, o, {
minFilter: e.LinearFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat
}));
var l = this.changed ? 8 * this.nextRenderMeanIndex : this.nextRenderIndex,
u = this.jitterOffsets[l + h];
this.camera.setViewOffset &&
this.camera.setViewOffset(d, o, 0.0625 * u[0], 0.0625 * u[1], d, o),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs :\n render.setRenderTarget(this.renderTarget[ i + beginning ]); \n renderer.clear(); \n this.renderer( this.scene, this.camera);"
),
t.render(this.scene, this.camera, this.renderTarget[h + s]);
}
return (
this.changed ||
(this.nextRenderIndex = Math.min(
this.nextRenderIndex + i,
Math.pow(2, this.sampleLevelMax)
)),
a - i
);
},
meanCalculation: function(t, r, n, a) {
this.jitterOffsets =
e.SSAAUnbiasedPass.JitterVectors[Math.max(0, Math.min(a, 5))];
for (
var i = this.changed
? this.jitterOffsets.length
: Math.pow(2, this.sampleLevelMin);
0 != i;

) {
i = this.createRenderTarget(t, r, n, i);
var s = this.changed ? this.jitterOffsets.length : this.nextRenderIndex;
if (s >= 8 && this.jitterOffsets.length > 8) {
if (s % 8 == 0) {
this.renderTargetMean[this.nextRenderMeanIndex] ||
(this.renderTargetMean[this.nextRenderMeanIndex] = new e.WebGLRenderTarget(
n.width,
n.height,
{minFilter: e.LinearFilter, magFilter: e.NearestFilter, format: e.RGBAFormat}
));
for (var h = 0; h < 8; h++) this.textureMean[h] = this.renderTarget[h].texture;
(this.uniformsMean.texture.value = this.textureMean),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs :\n render.setRenderTarget( [this.nextRenderMeanIndex] ); \n this.quadMean( renderer );"
),
t.render(
this.sceneQuadMean,
this.cameraQuad,
this.renderTargetMean[this.nextRenderMeanIndex]
),
(this.texture[this.nextRenderMeanIndex] = this.renderTargetMean[
this.nextRenderMeanIndex
].texture),
(this.uniforms.texture.value = this.texture),
this.nextRenderMeanIndex++;
}
this.quad.material = this.material[Math.trunc(s / 16)];
} else {
this.quad.material = this.material[this.changed ? a : Math.trunc(Math.log2(s))];
for (h = 0; h < Math.min(s, 8); h++)
this.texture[h] = this.renderTarget[h].texture;
this.uniforms.texture.value = this.texture;
}
}
},
render: function(t, r, n) {
var a = -1,
i = t.autoClear;
t.autoClear = !0;
var s = t.getClearColor().getHex(),
h = t.getClearAlpha();
if (!this.changed && this.autoCheckChange) {
var d = Math.pow(2, Math.ceil(Math.log2(n.width))),
o = Math.pow(2, Math.ceil(Math.log2(n.height)));
if (
(this.quadCompare ||
((this.quadCompare = new e.Mesh(
new e.PlaneBufferGeometry(2, 2),
this.materialCompare
)),
(this.quadCompare.frustumCulled = !1),
(this.sceneQuadCompare = new e.Scene()),
this.sceneQuadCompare.add(this.quadCompare),
(this.renderTargetCompare = new e.WebGLRenderTarget(d, o, {
minFilter: e.LinearFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat
}))),
(this.buffer = this.buffer || new Uint8Array(d * o * 4)),
(this.newRender =
this.newRender ||
new e.WebGLRenderTarget(d, o, {
minFilter: e.LinearFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat
})),
t.render(this.scene, this.camera, this.newRender),
this.oldRender)
) {
(this.materialCompare.uniforms.newRender.value = this.newRender.texture),
(this.materialCompare.uniforms.oldRender.value = this.oldRender.texture),
t.render(this.sceneQuadCompare, this.camera, this.renderTargetCompare),
t.readRenderTargetPixels(
this.renderTargetCompare,
0,
0,
n.width,
n.height,
this.buffer
);
for (var l = 0; l < this.buffer.length / 4; l += 4)
if (0 !== this.buffer[l]) {
this.hasChanged();
break;
}
var u = this.oldRender;
(this.oldRender = this.newRender), (this.newRender = u);
} else
this.hasChanged(), (this.oldRender = this.newRender), (this.newRender = null);
}
this.changed
? ((a = this.sampleLevelMin),
  (this.finalRenderDone = !1),
  (this.nextRenderMeanIndex = 0))
: (a = this.sampleLevelMax),
this.finalRenderDone ||
(this.meanCalculation(t, r, n, a),
this.nextRenderIndex === Math.pow(2, this.sampleLevelMax) &&
(this.finalRenderDone = !0)),
this.renderToScreen
? ("101" !== e.REVISION &&
  console.error(
  "In next versions of threejs :\n renderer.setRenderTarget( null ); \n this.quad.render( renderer );"
  ),
  t.render(this.sceneQuad, this.cameraQuad))
: ("101" !== e.REVISION &&
  console.error(
  "In next versions of threejs :\n renderer.setRenderTarget( writeBuffer ); \n if ( this.clear ) renderer.clear();\n this.quad.render( renderer );"
  ),
  t.render(this.sceneQuad, this.cameraQuad, r)),
this.camera.clearViewOffset && this.camera.clearViewOffset(),
(t.autoClear = i),
t.setClearColor(s, h),
(this.changed = !1);
}
})),
(r.JitterVectors = [
[[0, 0]],
[[4, 4], [-4, -4]],
[[-2, -6], [6, -2], [-6, 2], [2, 6]],
[[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]],
[
[1, 1],
[-1, -3],
[-3, 2],
[4, -1],
[-5, -2],
[2, 5],
[5, 3],
[3, -5],
[-2, 6],
[0, -7],
[-4, -6],
[-6, 4],
[-8, 0],
[7, -4],
[6, 7],
[-7, -8]
],
[
[-4, -7],
[-7, -5],
[-3, -5],
[-5, -4],
[-1, -4],
[-2, -2],
[-6, -1],
[-4, 0],
[-7, 1],
[-1, 2],
[-6, 3],
[-3, 3],
[-7, 6],
[-3, 6],
[-5, 7],
[-1, 7],
[5, -7],
[1, -6],
[6, -5],
[4, -4],
[2, -3],
[7, -2],
[1, -1],
[4, -1],
[2, 1],
[6, 2],
[0, 4],
[4, 4],
[2, 5],
[7, 5],
[5, 6],
[3, 7]
]
]);
var n = r;
return (
(e.SSAAUnbiasedPass = n),
(e.SSAAUnbiasedShader = t),
{SSAAUnbiasedPass: n, SSAAUnbiasedShader: t}
);
});
