!(function(e, t) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = t(require("three")))
: "function" == typeof define && define.amd
? define(["three"], t)
: (e.THREEUnbiasedSSAA = t(e.THREE));
})(this, function(e) {
"use strict";
(e = e && e.hasOwnProperty("default") ? e.default : e),
(function(t, r, n) {
if (void 0 === e[t])
throw `THREE is missing example '${t}' and, as such, three-js-unbiased-ssaa can't work properly. You can find it` +
` in '@dualbox/three/examples/js/${void 0 !== r ? r + "/" : ""}${n || t}.js'`;
})("Pass", "postprocessing", "EffectComposer");
var t = {
defines: {NUMBER_TEXTURE: 0},
uniforms: {texture: {value: null}},
vertexShader: [
"varying vec2 vUv;",
"void main() {",
"vUv = uv;",
"gl_Position = vec4( position, 1.0 );",
"}"
].join("\n"),
fragmentShader: [
"uniform sampler2D texture[ NUMBER_TEXTURE ];",
"varying vec2 vUv;",
"void main() {",
"vec4 color = vec4(0,0,0,0);",
"for (int i = 0; i < NUMBER_TEXTURE; i++)",
"{",
"color += texture2D( texture[i], vUv);",
"}",
"float nbrTex = float(NUMBER_TEXTURE);",
"gl_FragColor = color/nbrTex;",
"}"
].join("\n")
},
r = function(r, n, a, i) {
e.Pass.call(this),
(this.scene = r),
(this.camera = n),
(this.autoCheckChange = !1),
(this.newBuffer = null),
(this.oldBuffer = null),
(this.changed = !1),
(this.finalRenderDone = !1),
(this.sampleLevelMin = void 0 !== a ? a : 2),
(this.sampleLevelMax = void 0 !== i ? i : 5),
void 0 === t &&
console.error("THREE.SSAAUnbiasedPass relies on UnbiasedShader");
var s = t;
(this.uniforms = e.UniformsUtils.clone(s.uniforms)),
(this.texture = []),
(this.material = []);
for (var h = 0; h < 4; h++)
(this.material[h] = new e.ShaderMaterial({
uniforms: this.uniforms,
vertexShader: s.vertexShader,
fragmentShader: s.fragmentShader
})),
(this.material[h].defines.NUMBER_TEXTURE = Math.pow(2, h));
"101" !== e.REVISION &&
console.error(
"In next versions of threejs line 41 to 47:\n this.quad = new THREE.Pass.FullScreenQuad( this.material );"
),
(this.cameraQuad = new e.OrthographicCamera(-1, 1, 1, -1, 0, 1)),
(this.sceneQuad = new e.Scene()),
(this.quad = new e.Mesh(new e.PlaneBufferGeometry(2, 2), this.material)),
(this.quad.frustumCulled = !1),
this.sceneQuad.add(this.quad),
(this.renderTarget = []),
(this.nextRenderIndex = 0),
(this.uniformsMean = e.UniformsUtils.clone(s.uniforms)),
(this.textureMean = []),
(this.materialMean = new e.ShaderMaterial({
uniforms: this.uniformsMean,
vertexShader: s.vertexShader,
fragmentShader: s.fragmentShader
})),
(this.materialMean.defines.NUMBER_TEXTURE = 8),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs line 67 to 73:\n this.quadMean = new THREE.Pass.FullScreenQuad( this.materialMean );"
),
(this.sceneQuadMean = new e.Scene()),
(this.quadMean = new e.Mesh(
new e.PlaneBufferGeometry(2, 2),
this.materialMean
)),
(this.quadMean.frustumCulled = !1),
this.sceneQuadMean.add(this.quadMean),
(this.renderTargetMean = []),
(this.nextRenderMeanIndex = 0),
(this.materialCompare = new e.ShaderMaterial({
defines: {WIDTH_STEP: 0, HEIGHT_STEP: 0},
uniforms: {oldRender: {value: null}, newRender: {value: null}},
vertexShader: [
"varying vec2 vUv;",
"void main() {",
"   vUv = uv;",
"   gl_Position = vec4( position, 1.0 );",
"}"
].join("\n"),
fragmentShader: [
"uniform sampler2D oldRender;",
"uniform sampler2D newRender;",
"varying vec2 vUv;",
"void main() {",
"   float diff = 0.0;",
"   float sumDiff = 0.0;",
"   vec4 oldRenderUv;",
"   vec4 newRenderUv;",
"   for (float i = 0.; i < 1.; i += HEIGHT_STEP){",
"       for (float j = 0.; j < 1.; j += WIDTH_STEP){",
"           oldRenderUv = texture2D( oldRender, vec2(vUv[0] + i, vUv[1] + j) );",
"           newRenderUv = texture2D( newRender, vec2(vUv[0] + i, vUv[1] + j) );",
"           diff = clamp(abs(oldRenderUv[0]-newRenderUv[0]) + abs(oldRenderUv[1]-newRenderUv[1]) + abs(oldRenderUv[2]-newRenderUv[2]) + abs(oldRenderUv[3]-newRenderUv[3]),0.0,1.0);",
"           sumDiff += diff;",
"       }",
"   }",
"   gl_FragColor = vec4(sumDiff,0.,0.,0.);",
"}"
].join("\n")
})),
(this.quadCompare = new e.Mesh(
new e.PlaneBufferGeometry(2, 2),
this.materialCompare
)),
(this.quadCompare.frustumCulled = !1),
(this.sceneQuadCompare = new e.Scene()),
this.sceneQuadCompare.add(this.quadCompare);
};
(r.prototype = Object.assign(Object.create(e.Pass.prototype), {
constructor: r,
isFinalRenderDone: function() {
return this.finalRenderDone;
},
dispose: function() {
for (var e = 0; e < 4; e++) this.material[e].dispose();
for (e = 0; e < this.renderTarget.length; e++)
this.renderTarget[e] && this.renderTarget[e].dispose();
for (e = 0; e < this.renderTargetMean.length; e++)
this.renderTargetMean[e] && this.renderTargetMean[e].dispose();
this.sceneQuad.dispose();
for (e = 0; e < 4; e++) this.sceneQuadMean[e].dispose();
this.materialMean.dispose(),
this.materialCompare.dispose(),
this.sceneCompare.dispose(),
this.newRender &&
(this.newRender.dispose(),
this.oldRender && this.oldRender.dispose(),
this.renderTargetCompare && this.renderTargetCompare.dispose(),
this.sceneQuadCompare && this.sceneQuadCompare.dispose());
},
setCamera: function(e) {
this.camera != e &&
((this.camera = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setScene: function(e) {
this.scene != e &&
((this.scene = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setSampleLevelMax: function(e) {
this.sampleLevelMax != e &&
((this.sampleLevelMax = e),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0)),
this.sampleLevelMax < this.sampleLevelMin &&
console.error("SampleLevelMax must be higher than sampleLevelMin");
},
setSampleLevelMin: function(e) {
(this.sampleLevelMin = e),
this.sampleLevelMax < this.sampleLevelMin &&
console.error("SampleLevelMax must be higher than sampleLevelMin");
},
hasChanged: function() {
this.changed ||
((this.changed = !0),
(this.finalRenderDone = !1),
(this.nextRenderIndex = 0),
(this.nextRenderMeanIndex = 0));
},
setAutoCheckChange: function(e) {
this.autoCheckChange = e;
},
setSize: function(e, t) {
for (var r = 0; r < this.renderTarget.length; r++)
this.renderTarget[r] && this.renderTarget[r].setSize(e, t),
this.renderTargetMean[r] && this.renderTargetMean[r].setSize(e, t);
if (this.newRender) {
var n = Math.ceil(Math.log2(e)),
a = Math.ceil(Math.log2(t)),
i = Math.pow(2, n),
s = Math.pow(2, a);
if (this.newRender.width !== i || this.newRender.height !== s) {
this.newRender.setSize(i, s),
this.oldRender && this.oldRender.setSize(i, s),
this.buffer && (this.buffer = new Uint8Array(i * s));
var h = Math.pow(2, n - 4),
d = Math.pow(2, a - 4);
(this.quadCompare.geometry.attributes.uv.array[1] /= d),
(this.quadCompare.geometry.attributes.uv.array[2] /= h),
(this.quadCompare.geometry.attributes.uv.array[3] /= d),
(this.quadCompare.geometry.attributes.uv.array[6] /= h),
(this.materialCompare.defines.WIDTH_STEP = 1 / h),
(this.materialCompare.defines.HEIGHT_STEP = 1 / d),
(this.materialCompare.needsUpdate = !0);
}
}
this.hasChanged();
},
createRenderTarget: function(t, r, n, a) {
for (
var i = Math.min(a, 8), s = this.nextRenderIndex % 8, h = 0;
h < Math.min(i, Math.pow(2, this.sampleLevelMax) - this.nextRenderIndex);
h++
) {
var d = n.width,
o = n.height;
this.renderTarget[h + s] ||
(this.renderTarget[h + s] = new e.WebGLRenderTarget(d, o, {
minFilter: e.NearestFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat
}));
var l = this.changed ? 8 * this.nextRenderMeanIndex : this.nextRenderIndex,
u = this.jitterOffsets[l + h];
this.camera.setViewOffset &&
this.camera.setViewOffset(d, o, 0.0625 * u[0], 0.0625 * u[1], d, o),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs :\n render.setRenderTarget(this.renderTarget[ i + beginning ]); \n renderer.clear(); \n this.renderer( this.scene, this.camera);"
),
t.render(this.scene, this.camera, this.renderTarget[h + s]);
}
return (
this.changed ||
(this.nextRenderIndex = Math.min(
this.nextRenderIndex + i,
Math.pow(2, this.sampleLevelMax)
)),
a - i
);
},
meanCalculation: function(t, r, n, a) {
this.jitterOffsets =
e.SSAAUnbiasedPass.JitterVectors[Math.max(0, Math.min(a, 5))];
for (
var i = this.changed
? this.jitterOffsets.length
: Math.pow(2, this.sampleLevelMin);
0 != i;

) {
i = this.createRenderTarget(t, r, n, i);
var s = this.changed ? this.jitterOffsets.length : this.nextRenderIndex;
if (s >= 8 && this.jitterOffsets.length > 8) {
if (s % 8 == 0) {
this.renderTargetMean[this.nextRenderMeanIndex] ||
(this.renderTargetMean[this.nextRenderMeanIndex] = new e.WebGLRenderTarget(
n.width,
n.height,
{
minFilter: e.NearestFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat,
depthBuffer: !1,
stencilBuffer: !1
}
));
for (var h = 0; h < 8; h++) this.textureMean[h] = this.renderTarget[h].texture;
(this.uniformsMean.texture.value = this.textureMean),
"101" !== e.REVISION &&
console.error(
"In next versions of threejs :\n render.setRenderTarget( [this.nextRenderMeanIndex] ); \n this.quadMean( renderer );"
),
t.render(
this.sceneQuadMean,
this.cameraQuad,
this.renderTargetMean[this.nextRenderMeanIndex]
),
(this.texture[this.nextRenderMeanIndex] = this.renderTargetMean[
this.nextRenderMeanIndex
].texture),
(this.uniforms.texture.value = this.texture),
this.nextRenderMeanIndex++;
}
this.quad.material = this.material[Math.trunc(s / 16)];
} else {
this.quad.material = this.material[this.changed ? a : Math.trunc(Math.log2(s))];
for (h = 0; h < Math.min(s, 8); h++)
this.texture[h] = this.renderTarget[h].texture;
this.uniforms.texture.value = this.texture;
}
}
},
render: function(t, r, n) {
var a = -1,
i = t.autoClear;
t.autoClear = !0;
var s = t.getClearColor().getHex(),
h = t.getClearAlpha();
if (!this.changed && this.autoCheckChange) {
var d = Math.ceil(Math.log2(n.width)),
o = Math.ceil(Math.log2(n.height)),
l = Math.pow(2, d),
u = Math.pow(2, o);
if (
((this.newRender =
this.newRender ||
new e.WebGLRenderTarget(l, u, {
minFilter: e.NearestFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat
})),
t.render(this.scene, this.camera, this.newRender),
this.oldRender)
) {
(this.materialCompare.uniforms.newRender.value = this.newRender.texture),
(this.materialCompare.uniforms.oldRender.value = this.oldRender.texture),
t.render(this.sceneQuadCompare, this.camera, this.renderTargetCompare),
(this.buffer = this.buffer || new Uint8Array(1024)),
t.readRenderTargetPixels(this.renderTargetCompare, 0, 0, 16, 16, this.buffer);
for (var m = 0; m < this.buffer.length; m += 4)
if (0 !== this.buffer[m]) {
this.hasChanged();
break;
}
var f = this.oldRender;
(this.oldRender = this.newRender), (this.newRender = f);
} else {
this.renderTargetCompare = new e.WebGLRenderTarget(16, 16, {
minFilter: e.NearestFilter,
magFilter: e.NearestFilter,
format: e.RGBAFormat,
depthBuffer: !1,
stencilBuffer: !1
});
var c = Math.pow(2, d - 4),
v = Math.pow(2, o - 4);
(this.quadCompare.geometry.attributes.uv.array[1] /= v),
(this.quadCompare.geometry.attributes.uv.array[2] /= c),
(this.quadCompare.geometry.attributes.uv.array[3] /= v),
(this.quadCompare.geometry.attributes.uv.array[6] /= c),
(this.materialCompare.defines.WIDTH_STEP = 1 / c),
(this.materialCompare.defines.HEIGHT_STEP = 1 / v),
this.hasChanged(),
(this.oldRender = this.newRender),
(this.newRender = null);
}
}
this.changed
? ((a = this.sampleLevelMin),
  (this.finalRenderDone = !1),
  (this.nextRenderMeanIndex = 0))
: (a = this.sampleLevelMax),
this.finalRenderDone ||
(this.meanCalculation(t, r, n, a),
this.nextRenderIndex === Math.pow(2, this.sampleLevelMax) &&
(this.finalRenderDone = !0)),
this.renderToScreen
? ("101" !== e.REVISION &&
  console.error(
  "In next versions of threejs :\n renderer.setRenderTarget( null ); \n this.quad.render( renderer );"
  ),
  t.render(this.sceneQuad, this.cameraQuad))
: ("101" !== e.REVISION &&
  console.error(
  "In next versions of threejs :\n renderer.setRenderTarget( writeBuffer ); \n if ( this.clear ) renderer.clear();\n this.quad.render( renderer );"
  ),
  t.render(this.sceneQuad, this.cameraQuad, r)),
this.camera.clearViewOffset && this.camera.clearViewOffset(),
(t.autoClear = i),
t.setClearColor(s, h),
(this.changed = !1);
}
})),
(r.JitterVectors = [
[[0, 0]],
[[4, 4], [-4, -4]],
[[-2, -6], [6, -2], [-6, 2], [2, 6]],
[[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]],
[
[1, 1],
[-1, -3],
[-3, 2],
[4, -1],
[-5, -2],
[2, 5],
[5, 3],
[3, -5],
[-2, 6],
[0, -7],
[-4, -6],
[-6, 4],
[-8, 0],
[7, -4],
[6, 7],
[-7, -8]
],
[
[-4, -7],
[-7, -5],
[-3, -5],
[-5, -4],
[-1, -4],
[-2, -2],
[-6, -1],
[-4, 0],
[-7, 1],
[-1, 2],
[-6, 3],
[-3, 3],
[-7, 6],
[-3, 6],
[-5, 7],
[-1, 7],
[5, -7],
[1, -6],
[6, -5],
[4, -4],
[2, -3],
[7, -2],
[1, -1],
[4, -1],
[2, 1],
[6, 2],
[0, 4],
[4, 4],
[2, 5],
[7, 5],
[5, 6],
[3, 7]
]
]);
const n = {SSAAUnbiasedPass: r, SSAAUnbiasedShader: t};
return (
(e.SSAAUnbiasedPass = n.SSAAUnbiasedPass),
(e.SSAAUnbiasedShader = n.SSAAUnbiasedShader),
n
);
});
